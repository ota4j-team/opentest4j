/*
 * Copyright 2015-2016 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.opentest4j.fixtures;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotates static fields that reference test fixtures or methods that return them. A field must be public,
 * static and implement {@link TestFixture}. A method must be public static, and return
 * a subtype of {@code TestFixture}. Fields and methods of this type are called Class Fixtures.
 *
 * <p>Class fixtures will be initialized before all the test methods in a the class or fixture
 * where the fixture is installed, and will have their teardowns and postconditions called after
 * all the test methods. The fixture initiation occurs before any class-based initialization
 * (ex: {@code BeforeClass} methods in JUnit), and the postconditions and teardowns are called after all
 * class-based teardowns (ex: {@code AfterClass} methods in JUnit).
 *
 * If there are multiple members annotated with {@link TestFixture} in a class, they will be
 * applied in an order that depends on your JVM's implementation of the reflection API, which is
 * undefined, in general. However, fixtures defined by fields will always be applied before fixtures
 * defined by methods.
 *
 * <p> For example, here is a JUnit test suite that connects to a server once before
 * all the test classes run, and disconnects after they are finished:
 * <pre>
 * &#064;RunWith(Suite.class)
 * &#064;SuiteClasses({A.class, B.class, C.class})
 * public class UsesServer {
 *     public static final Server myServer = new Server();
 *
 *     &#064;ClassFixture
 *     public static AbstractTestFixture runServer = new AbstractTestFixture() {
 *       &#064;Override
 *       protected void beforeTest() throws Exception {
 *          myServer.connect();
 *      }
 *
 *      &#064;Override
 *      protected void afterTest() throws Exception {
 *          myServer.disconnect();
 *      }
 *   };
 * }
 * </pre>
 * <p>
 * and the same using a method
 * <pre>
 * &#064;RunWith(Suite.class)
 * &#064;SuiteClasses({A.class, B.class, C.class})
 * public class UsesServer {
 *     public static final Server myServer = new Server();
 *
 *     &#064;ClassFixture
 *     public static TestFixture runServer() {
 *         return new AbstractTestFixture() {
 *             &#064;Override
 *             protected void beforeTest() throws Exception {
 *                 myServer.connect();
 *             }
 *
 *             &#064;Override
 *             protected void afterTest() throws Exception {
 *                 myServer.disconnect();
 *             }
 *         };
 *     }
 * }
 * </pre>
 *
 * @since 1.1
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.FIELD, ElementType.METHOD })
public @interface ClassFixture {
}
