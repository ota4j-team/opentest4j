/*
 * Copyright 2016 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.opentest4j.fixtures;

import static java.util.Objects.requireNonNull;
import static org.opentest4j.fixtures.Utils.rethrowAsException;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;

/**
 * Manages the interaction of a {@link TestFixture}
 *
 * @author Kevin Cooney
 * @since 1.1
 */
public final class FixtureManager {
	private final Deque<TearDown> tearDowns = new ArrayDeque<TearDown>();
	private final List<TestPostcondition> testPostconditions = new ArrayList<TestPostcondition>();
	private final ClassWrapper testClass;
	private final InstanceMethod testMethod;
	private State state = State.HEALTHY;

	/** Creates a fixture manager for the given test method. */
	public static FixtureManager forTestMethod(InstanceMethod testMethod) {
		return new FixtureManager(testMethod.getJavaClass(), requireNonNull(testMethod, "testMethod cannot be null"));
	}

	/** Creates a fixture manager for the given test class. */
	public static FixtureManager forTestClass(ClassWrapper testClass) {
		return new FixtureManager(requireNonNull(testClass), null);
	}

	/**
	 * Initializes a fixture, registering any tear downs or postconditions
	 * registered by the fixture initialization. If
	 * {@link TestFixture#initialize(FixtureContext)} throws an exception, then
	 * all registered tear downs will be executed.
	 *
	 * @throws Exception
	 *             exception thrown during
	 *             {@code TestFixture#initialize(FixtureContext)}
	 */
	public void initializeFixture(TestFixture testFixture) throws Exception {
		requireNonNull(testFixture);
		state.checkCanModifyFixture();
		FixtureContextFacade context = new FixtureContextFacade();
		try {
			context.initialize(testFixture);
		} catch (Throwable e) {
			List<Throwable> suppressedErrors = new ArrayList<Throwable>();
			runAllTearDowns(suppressedErrors);

			for (Throwable suppressedError : suppressedErrors) {
				e.addSuppressed(suppressedError);
			}
			rethrowAsException(e);
		}
	}

	/**
	 * Resets this fixture to its initial state.
	 */
	public void reset() {
		state = State.HEALTHY;
		tearDowns.clear();
		testPostconditions.clear();
	}

	/**
	 * Adds a {@link TearDown} to run after the test completes.
	 */
	public void addTearDown(TearDown tearDown) {
		requireNonNull(tearDown);
		state.checkCanModifyFixture();
		tearDowns.add(tearDown);
	}

	/**
	 * Runs all of the {@link TearDown} instances managed by this class.
	 * 
	 * @param errors
	 *            filled in with a list of all errors encountered while running
	 *            the tear downs.
	 */
	public void runAllTearDowns(List<Throwable> errors) {
		requireNonNull(errors);
		state = state.startRunTearDowns();

		while (!tearDowns.isEmpty()) {
			try {
				tearDowns.pop().tearDown();
			} catch (Throwable e) {
				errors.add(e);
			}
		}
		state = State.COMPLETED;
	}

	/**
	 * Runs the {@link TestPostcondition} instances managed by this class. If
	 * any of the postconditions throws an exception, this method will throw
	 * that exception. If no postconditions throw an exception, then all
	 * postconditions will be callled.
	 * 
	 * @throws Exception
	 *             exception thrown from first failing postcondition
	 */
	public void runAllPostconditions() throws Exception {
		state = state.startRunPostConditions();

		try {
			for (TestPostcondition postcondition : testPostconditions) {
				postcondition.verify();
			}
		} finally {
			testPostconditions.clear();
		}
	}

	private FixtureManager(ClassWrapper testClass, InstanceMethod testMethod) {
		this.testMethod = testMethod;
		this.testClass = testClass;
	}

	private class FixtureContextFacade extends FixtureContext {
		private boolean initialized = false;

		public void initialize(TestFixture testFixture) throws Throwable {
			if (initialized) {
				throw new IllegalStateException("Already initialized");
			}
			try {
				testFixture.initialize(this);
			} finally {
				initialized = true;
			}
		}

		@Override
		public void addTearDown(TearDown tearDown) {
			requireNonNull(tearDown);
			state.checkCanModifyFixture();
			tearDowns.add(tearDown);
		}

		@Override
		public void addTestPostcondition(TestPostcondition postcondition) {
			requireNonNull(postcondition);
			state.checkCanModifyFixture();
			testPostconditions.add(postcondition);
		}

		@Override
		public InstanceMethod getInstanceMethod() {
			return testMethod;
		}

		@Override
		public ClassWrapper getTestClass() {
			return testClass;
		}
	}

	private enum State {
		HEALTHY {
			@Override
			void checkCanModifyFixture() {
			}

			@Override
			State startRunPostConditions() {
				return READY_FOR_TEARDOWN;
			}

			@Override
			State startRunTearDowns() {
				return RUNNING_TEAR_DOWNS;
			}
		},
		READY_FOR_TEARDOWN {
			@Override
			void checkCanModifyFixture() {
				throw new IllegalStateException();
			}

			@Override
			State startRunPostConditions() {
				throw new IllegalStateException();
			}

			@Override
			State startRunTearDowns() {
				return RUNNING_TEAR_DOWNS;
			}
		},
		RUNNING_TEAR_DOWNS {
			@Override
			void checkCanModifyFixture() {
				throw new IllegalStateException();
			}

			@Override
			State startRunPostConditions() {
				throw new IllegalStateException();
			}

			@Override
			State startRunTearDowns() {
				throw new IllegalStateException();
			}
		},
		COMPLETED {
			@Override
			void checkCanModifyFixture() {
				throw new IllegalStateException();
			}

			@Override
			State startRunPostConditions() {
				throw new IllegalStateException();
			}

			@Override
			State startRunTearDowns() {
				throw new IllegalStateException();
			}
		};

		abstract void checkCanModifyFixture();

		abstract State startRunPostConditions();

		abstract State startRunTearDowns();
	}
}
