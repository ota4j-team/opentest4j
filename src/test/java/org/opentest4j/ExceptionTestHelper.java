/*
 * Copyright 2015-2016 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.opentest4j;

import static org.junit.Assert.*;

import java.util.Set;

import org.opentest4j.debug.DebugInformation;
import org.opentest4j.debug.DebuggableObject;

/**
 * Utility to perform some standard checks to exceptions.
 *
 * @author Mark Michaelis
 * @since 1.0
 */
@SuppressWarnings("ThrowableInstanceNeverThrown")
public final class ExceptionTestHelper {

	public static final Exception CAUSE_EXCEPTION = new RuntimeException("the cause");
	public static final RuntimeException EXCEPTION_REFERENCE_ONLY_CAUSE = new RuntimeException(CAUSE_EXCEPTION);
	public static final RuntimeException EXCEPTION_REFERENCE_NO_ARG = new RuntimeException();
	public static final String MESSAGE_REFERENCE = "  the   message  ";
	public static final RuntimeException EXCEPTION_REFERENCE_MESSAGE_CAUSE = new RuntimeException(MESSAGE_REFERENCE,
		CAUSE_EXCEPTION);
	public static final RuntimeException EXCEPTION_REFERENCE_ONLY_MESSAGE = new RuntimeException(MESSAGE_REFERENCE);
	public static final DebugInformation DEBUG_INFORMATION_REFERENCE = DebugInformation.builder().put("expected",
		"a").put("actual", "b").build();

	//<editor-fold desc="/* First Level Assertions (Public) */">
	//------------------------------------------------------------------------------------------------------------------

	public static void assertBehavesLikeStandardException(Class<? extends Throwable> exceptionClass) throws Exception {
		assertNoArgConstructorBehavesAsExpected(exceptionClass);
		assertOnlyMessageConstructorBehavesAsExpected(exceptionClass);
		assertOnlyCauseConstructorBehavesAsExpected(exceptionClass);
		assertMessageCauseConstructorBehavesAsExpected(exceptionClass);
	}

	public static void assertBehavesLikeDebuggableException(Class<? extends Throwable> exceptionClass)
			throws Exception {
		assertBehavesLikeStandardException(exceptionClass);

		assertOnlyDebugInformationConstructorBehavesAsExpected(exceptionClass);
		assertDebugInformationCauseConstructorBehavesAsExpected(exceptionClass);
		assertMessageDebugInformationConstructorBehavesAsExpected(exceptionClass);
		assertMessageDebugInformationCauseConstructorBehavesAsExpected(exceptionClass);
	}

	//</editor-fold>

	//<editor-fold desc="/* Second Level Assertions (Standard) */">
	//------------------------------------------------------------------------------------------------------------------

	private static void assertNoArgConstructorBehavesAsExpected(Class<? extends Throwable> exceptionClass)
			throws Exception {
		Throwable exceptionInstance = exceptionClass.getConstructor().newInstance();

		assertExceptionSimilarTo("no arg", EXCEPTION_REFERENCE_NO_ARG, exceptionInstance);
		ifDebuggableAssertHasNoDebugInformation(exceptionInstance);
		assertCanInitCause(exceptionInstance);

		Throwable deserializedInstance = exceptionClass.cast(
			TestSerializationHelper.serializeAndDeserialize(exceptionInstance));
		assertExceptionEqualTo("serialization", exceptionInstance, deserializedInstance);
	}

	private static void assertOnlyMessageConstructorBehavesAsExpected(Class<? extends Throwable> exceptionClass)
			throws Exception {
		Throwable exceptionInstance = exceptionClass.getConstructor(String.class).newInstance(MESSAGE_REFERENCE);

		assertExceptionSimilarTo("only message", EXCEPTION_REFERENCE_ONLY_MESSAGE, exceptionInstance);
		ifDebuggableAssertHasNoDebugInformation(exceptionInstance);
		assertCanInitCause(exceptionInstance);

		Throwable deserializedInstance = exceptionClass.cast(
			TestSerializationHelper.serializeAndDeserialize(exceptionInstance));
		assertExceptionEqualTo("serialization", exceptionInstance, deserializedInstance);
	}

	private static void assertOnlyCauseConstructorBehavesAsExpected(Class<? extends Throwable> exceptionClass)
			throws Exception {
		Throwable exceptionInstance = exceptionClass.getConstructor(Throwable.class).newInstance(CAUSE_EXCEPTION);

		assertExceptionSimilarTo("only cause", EXCEPTION_REFERENCE_ONLY_CAUSE, exceptionInstance);
		ifDebuggableAssertHasNoDebugInformation(exceptionInstance);
		assertCannotInitCause(exceptionInstance);

		Throwable deserializedInstance = exceptionClass.cast(
			TestSerializationHelper.serializeAndDeserialize(exceptionInstance));
		assertExceptionEqualTo("serialization", exceptionInstance, deserializedInstance);
	}

	private static void assertMessageCauseConstructorBehavesAsExpected(Class<? extends Throwable> exceptionClass)
			throws Exception {
		Throwable exceptionInstance = exceptionClass.getConstructor(String.class, Throwable.class).newInstance(
			MESSAGE_REFERENCE, CAUSE_EXCEPTION);

		assertExceptionSimilarTo("message and cause", EXCEPTION_REFERENCE_MESSAGE_CAUSE, exceptionInstance);
		ifDebuggableAssertHasNoDebugInformation(exceptionInstance);
		assertCannotInitCause(exceptionInstance);

		Throwable deserializedInstance = exceptionClass.cast(
			TestSerializationHelper.serializeAndDeserialize(exceptionInstance));
		assertExceptionEqualTo("serialization", exceptionInstance, deserializedInstance);
	}

	//</editor-fold>

	//<editor-fold desc="/* Second Level Assertions (Debuggable) */">
	//------------------------------------------------------------------------------------------------------------------

	private static void assertOnlyDebugInformationConstructorBehavesAsExpected(
			Class<? extends Throwable> exceptionClass) throws Exception {
		Throwable exceptionInstance = exceptionClass.getConstructor(DebugInformation.class).newInstance(
			DEBUG_INFORMATION_REFERENCE);

		assertExceptionSimilarTo("only debuginformation", EXCEPTION_REFERENCE_NO_ARG, exceptionInstance);
		assertCanInitCause(exceptionInstance);
		assertTrue("instance of DebuggableObject", exceptionInstance instanceof DebuggableObject);
		DebuggableObject debuggableObject = (DebuggableObject) exceptionInstance;
		assertTrue("hasDebugInformation", debuggableObject.hasDebugInformation());
		assertSame("debugInformation", DEBUG_INFORMATION_REFERENCE, debuggableObject.getDebugInformation());

		Throwable deserializedInstance = exceptionClass.cast(
			TestSerializationHelper.serializeAndDeserialize(exceptionInstance));
		assertExceptionEqualTo("serialization", exceptionInstance, deserializedInstance);
		assertHaveEqualDebugInformation((DebuggableObject) exceptionInstance, (DebuggableObject) deserializedInstance);
	}

	private static <T extends Throwable> void assertDebugInformationCauseConstructorBehavesAsExpected(
			Class<T> exceptionClass) throws Exception {
		T exceptionInstance = exceptionClass.getConstructor(DebugInformation.class, Throwable.class).newInstance(
			DEBUG_INFORMATION_REFERENCE, CAUSE_EXCEPTION);

		assertExceptionSimilarTo("cause and debug information", EXCEPTION_REFERENCE_ONLY_CAUSE, exceptionInstance);
		assertCannotInitCause(exceptionInstance);

		T deserializedInstance = exceptionClass.cast(
			TestSerializationHelper.serializeAndDeserialize(exceptionInstance));
		assertExceptionEqualTo("serialization", exceptionInstance, deserializedInstance);
		assertHaveEqualDebugInformation((DebuggableObject) exceptionInstance, (DebuggableObject) deserializedInstance);
	}

	private static <T extends Throwable> void assertMessageDebugInformationConstructorBehavesAsExpected(
			Class<T> exceptionClass) throws Exception {
		T exceptionInstance = exceptionClass.getConstructor(String.class, DebugInformation.class).newInstance(
			MESSAGE_REFERENCE, DEBUG_INFORMATION_REFERENCE);

		assertExceptionSimilarTo("message and debug information", EXCEPTION_REFERENCE_ONLY_MESSAGE, exceptionInstance);
		assertCanInitCause(exceptionInstance);

		T deserializedInstance = exceptionClass.cast(
			TestSerializationHelper.serializeAndDeserialize(exceptionInstance));
		assertExceptionEqualTo("serialization", exceptionInstance, deserializedInstance);
		assertHaveEqualDebugInformation((DebuggableObject) exceptionInstance, (DebuggableObject) deserializedInstance);
	}

	private static <T extends Throwable> void assertMessageDebugInformationCauseConstructorBehavesAsExpected(
			Class<T> exceptionClass) throws Exception {
		T exceptionInstance = exceptionClass.getConstructor(String.class, DebugInformation.class,
			Throwable.class).newInstance(MESSAGE_REFERENCE, DEBUG_INFORMATION_REFERENCE, CAUSE_EXCEPTION);

		assertExceptionSimilarTo("message, debug information and cause", EXCEPTION_REFERENCE_MESSAGE_CAUSE,
			exceptionInstance);
		assertCannotInitCause(exceptionInstance);

		T deserializedInstance = exceptionClass.cast(
			TestSerializationHelper.serializeAndDeserialize(exceptionInstance));
		assertExceptionEqualTo("serialization", exceptionInstance, deserializedInstance);
		assertHaveEqualDebugInformation((DebuggableObject) exceptionInstance, (DebuggableObject) deserializedInstance);
	}

	//</editor-fold>

	//<editor-fold desc="/* Third Level Assertions */">

	/**
	 * Asserts that the two given exception are equal to another with respect for standard exceptions parameters.
	 *
	 * @param message message prefix
	 * @param expected expected exception to compare to
	 * @param actual actual exception
	 */
	private static void assertExceptionEqualTo(String message, Throwable expected, Throwable actual) {
		assertTrue(message + ":null", expected == null ? actual == null : actual != null);
		if (expected == null) {
			return;
		}
		assertSame(message + ":class", expected.getClass(), actual.getClass());
		assertExceptionSimilarTo(message, expected, actual);
	}

	/**
	 * Asserts that the two given exceptions are equal except for their class.
	 *
	 * @param message message prefix
	 * @param expected expected exception to compare to
	 * @param actual actual exception
	 */
	private static void assertExceptionSimilarTo(String message, Throwable expected, Throwable actual) {
		assertEquals(message + ":message", expected.getMessage(), actual.getMessage());
		assertEquals(message + ":localized message", expected.getLocalizedMessage(), actual.getLocalizedMessage());
		assertExceptionEqualTo(message + ":cause", expected.getCause(), actual.getCause());
	}

	//</editor-fold>

	//<editor-fold desc="/* Base Level Assertions */">
	//------------------------------------------------------------------------------------------------------------------

	private static void ifDebuggableAssertHasNoDebugInformation(Throwable th) {
		if (th instanceof DebuggableObject) {
			DebuggableObject debuggableObject = (DebuggableObject) th;
			assertFalse("hasDebugInformation", debuggableObject.hasDebugInformation());
			assertNull("debugInformation", debuggableObject.getDebugInformation());
		}
	}

	private static void assertHaveEqualDebugInformation(DebuggableObject expected, DebuggableObject actual) {
		assertTrue("hasDebugInformation", actual.hasDebugInformation());
		DebugInformation debugInformation = expected.getDebugInformation();
		DebugInformation deserializedDebugInformation = actual.getDebugInformation();
		Set<String> keys = debugInformation.keySet();
		for (String key : keys) {
			assertTrue(deserializedDebugInformation.containsKey(key));
			assertEquals(key, debugInformation.get(key), deserializedDebugInformation.get(key));
		}
	}

	private static void assertCanInitCause(Throwable th) {
		try {
			th.initCause(CAUSE_EXCEPTION);
			assertSame("cause after init", th.getCause(), CAUSE_EXCEPTION);
		}
		catch (Exception e) {
			fail("Should have been able to initialize cause.");
		}
	}

	private static void assertCannotInitCause(Throwable th) {
		Throwable causeBefore = th.getCause();
		try {
			th.initCause(CAUSE_EXCEPTION);
			fail("Should have failed as cause is already initialized.");
		}
		catch (Exception e) {
			assertSame("cause unchanged after init", th.getCause(), causeBefore);
		}
	}

	//</editor-fold>

}
