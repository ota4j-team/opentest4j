/*
 * Copyright 2015-2016 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.opentest4j.fixtures;

import static org.hamcrest.CoreMatchers.hasItem;
import static org.hamcrest.core.IsNot.not;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.failureCountIs;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.experimental.categories.Category;
import org.junit.rules.TestName;
import org.junit.runners.model.MultipleFailureException;
import org.opentest4j.InternalTest;

/**
 * Tests for {@link TemporaryDirectory}.
 *
 * @author Kevin Cooney
 */
public class TemporaryDirectoryTest {
	private static final ClassWrapper CLASS_WRAPPER = new ClassWrapper(TemporaryDirectoryTest.class);
	private static File[] createdFiles;

	@Before
	public void resetStaticFields() {
		createdFiles = new File[20];
	}

	/** Base class that simulates JUnit support for test fixtures. */
	public static abstract class TestWithSimulatedFixtureSupport {
		@Rule
		public final TestName testName = new TestName();

		public final TemporaryDirectory tmpDir = new TemporaryDirectory();
		private FixtureManager fixtureManager = FixtureManager.forTestClass(new ClassWrapper(getClass()));

		@Before
		public void simulateFixtureSetup() throws Exception {
			ClassWrapper testClass = new ClassWrapper(getClass());
			Method method = getClass().getMethod(testName.getMethodName());
			InstanceMethod testMethod = new InstanceMethod(testClass, method, this);
			fixtureManager = FixtureManager.forTestMethod(testMethod);

			fixtureManager.initializeFixture(tmpDir);
		}

		@After
		public void simulateFixtureTearDown() throws Exception {
			runAllTearDowns(fixtureManager);
		}
	}

	@Category(InternalTest.class)
	public static class HasTempDirectory extends TestWithSimulatedFixtureSupport {

		@Test
		public void testUsingTempDirectory() throws IOException {
			createdFiles[0] = tmpDir.newFile("myfile.txt");
			assertTrue(createdFiles[0].exists());
		}
	}

	@Test
	public void tempDirectoryIsDeleted() {
		assertThat(testResult(HasTempDirectory.class), isSuccessful());
		assertFalse(createdFiles[0].exists());
	}

	@Category(InternalTest.class)
	public static class CreatesSubDirectory extends TestWithSimulatedFixtureSupport {

		@Test
		public void testUsingTempDirectoryString() throws IOException {
			String subDir = "subdir";
			String filename = "a.txt";
			// ensure that a single String works
			createdFiles[0] = tmpDir.newDirectory(subDir);
			new File(createdFiles[0], filename).createNewFile();

			File expectedFile = new File(tmpDir.getRoot(), join(subDir, filename));

			assertTrue(expectedFile.exists());
		}

		@Test
		public void testUsingTempTreeDirectories() throws IOException {
			String subDir = "subDir";
			String anotherDir = "anotherDir";
			String filename = "a.txt";

			File createdFile = tmpDir.newDirectory(subDir, anotherDir);
			new File(createdFile, filename).createNewFile();

			File expectedFile = new File(tmpDir.getRoot(), join(subDir, anotherDir, filename));

			assertTrue(expectedFile.exists());
		}

		private String join(String... dirNames) {
			StringBuilder path = new StringBuilder();
			for (String dirName : dirNames) {
				path.append(File.separator).append(dirName);
			}
			return path.toString();
		}
	}

	@Test
	public void subDirectoryIsDeleted() {
		assertThat(testResult(CreatesSubDirectory.class), isSuccessful());
		assertFalse(createdFiles[0].exists());
	}

	@Category(InternalTest.class)
	public static class CreatesRandomSubDirectories extends TestWithSimulatedFixtureSupport {

		@Test
		public void testUsingRandomTempDirectories() throws IOException {
			for (int i = 0; i < createdFiles.length; i++) {
				File newDir = tmpDir.newDirectory();
				assertThat(Arrays.asList(createdFiles), not(hasItem(newDir)));
				createdFiles[i] = newDir;
				new File(newDir, "a.txt").createNewFile();
				assertTrue(newDir.exists());
			}
		}
	}

	@Test
	public void randomSubDirectoriesAreDeleted() {
		assertThat(testResult(CreatesRandomSubDirectories.class), isSuccessful());
		for (File f : createdFiles) {
			assertFalse(f.exists());
		}
	}

	@Category(InternalTest.class)
	public static class CreatesRandomFiles extends TestWithSimulatedFixtureSupport {

		@Test
		public void testUsingRandomTempFiles() throws IOException {
			for (int i = 0; i < 20; i++) {
				File newFile = tmpDir.newFile();
				assertThat(Arrays.asList(createdFiles), not(hasItem(newFile)));
				createdFiles[i] = newFile;
				assertTrue(newFile.exists());
			}
		}
	}

	@Test
	public void randomFilesAreDeleted() {
		assertThat(testResult(CreatesRandomFiles.class), isSuccessful());
		for (File f : createdFiles) {
			assertFalse(f.exists());
		}
	}

	@Test
	public void recursiveDeleteDirectoryWithOneElement() throws Throwable {
		TemporaryDirectory tmpDir = new TemporaryDirectory();
		FixtureManager fixtureManager = FixtureManager.forTestClass(CLASS_WRAPPER);
		fixtureManager.initializeFixture(tmpDir);
		File file = tmpDir.newFile("a");
		runAllTearDowns(fixtureManager);
		assertFalse(file.exists());
		assertFalse(tmpDir.getRoot().exists());
	}

	@Test
	public void recursiveDeleteDirectoryWithOneRandomElement() throws Throwable {
		TemporaryDirectory tmpDir = new TemporaryDirectory();
		FixtureManager fixtureManager = FixtureManager.forTestClass(CLASS_WRAPPER);
		fixtureManager.initializeFixture(tmpDir);
		File file = tmpDir.newFile();
		runAllTearDowns(fixtureManager);

		assertFalse(file.exists());
		assertFalse(tmpDir.getRoot().exists());
	}

	@Test
	public void recursiveDeleteDirectoryWithZeroElements() throws Throwable {
		TemporaryDirectory tmpDir = new TemporaryDirectory();
		FixtureManager fixtureManager = FixtureManager.forTestClass(CLASS_WRAPPER);
		fixtureManager.initializeFixture(tmpDir);
		runAllTearDowns(fixtureManager);

		assertFalse(tmpDir.getRoot().exists());
	}

	@Category(InternalTest.class)
	public static class NameClashes extends TestWithSimulatedFixtureSupport {

		@Test
		public void fileWithFileClash() throws IOException {
			tmpDir.newFile("something.txt");
			tmpDir.newFile("something.txt");
		}

		@Test
		public void fileWithDirectoryTest() throws IOException {
			tmpDir.newDirectory("dummy");
			tmpDir.newFile("dummy");
		}
	}

	@Test
	public void nameClashesResultInTestFailures() {
		assertThat(testResult(NameClashes.class), failureCountIs(2));
	}

	private static final String GET_ROOT_DUMMY = "dummy-getRoot";

	private static final String NEW_FILE_DUMMY = "dummy-newFile";

	private static final String NEW_DIR_DUMMY = "dummy-newDir";

	@Category(InternalTest.class)
	public static class IncorrectUsage {
		/** Fixture that where we don't simulate it being annotated with @Fixture */
		public final TemporaryDirectory tmpDir = new TemporaryDirectory();

		@Test
		public void testGetRoot() throws IOException {
			new File(tmpDir.getRoot(), GET_ROOT_DUMMY).createNewFile();
		}

		@Test
		public void testNewFile() throws IOException {
			tmpDir.newFile(NEW_FILE_DUMMY);
		}

		@Test
		public void testNewDirectory() throws IOException {
			tmpDir.newDirectory(NEW_DIR_DUMMY);
		}
	}

	@Test
	public void incorrectUsageWithoutAnnotatingTheFixtureShouldNotPolluteTheCurrentWorkingDirectory() {
		assertThat(testResult(IncorrectUsage.class), failureCountIs(3));
		assertFalse("getRoot should have failed early", new File(GET_ROOT_DUMMY).exists());
		assertFalse("newFile should have failed early", new File(NEW_FILE_DUMMY).exists());
		assertFalse("newDirectory should have failed early", new File(NEW_DIR_DUMMY).exists());
	}

	@After
	public void cleanCurrentWorkingDirectory() {
		new File(GET_ROOT_DUMMY).delete();
		new File(NEW_FILE_DUMMY).delete();
		new File(NEW_DIR_DUMMY).delete();
	}

	private static void runAllTearDowns(FixtureManager fixtureManager) throws Exception {
		List<Throwable> errors = new ArrayList<Throwable>();
		fixtureManager.runAllTearDowns(errors);
		MultipleFailureException.assertEmpty(errors);
	}
}
